(defparameter *active-player* 'nil)

(defun list-hand        () (mapcar (lambda (x) (format t "~a~%" (get-card-name x))) (get-player-hand *active-player*)))
(defun list-graveyard   () (mapcar (lambda (x) (format t "~a~%" (get-card-name x))) *graveyard*))
(defun list-exile       () (mapcar (lambda (x) (format t "~a~%" (get-card-name x))) *exile*))

(defun list-battlefield ()
        (mapcar (lambda (x) (print-card x)) *battlefield*))

(defun list-manapool ()
        (format t "~a~%" (get-player-manapool *active-player*)))

(defun list-commands ()
        (format t "commands available:~%")
        (format t "p                    - pass priority~%")
        (format t "h                    - list cards in hand~%")
        (format t "b                    - list cards on battlefield~%")
        (format t "g                    - list cards in graveyard~%")
        (format t "e                    - list cards in exile zone~%")
        (format t "fm                   - free mana~%")
        (format t "mp                   - see mana pool~%")
        (format t "desc [card]          - describe text on card~%")
        (format t "cast [card]          - cast a card~%")
        (format t "play [land]          - play a land~%")
        (format t "tap [bnum]           - tap a land for mana")
        (format t "activate [ability]   - activate an ability~%")
        (format t "faceup [permanent]   - turn a permanent faceup~%")
        (format t "concede              - concede the game~%"))

(defun free-mana ()
        (set-player-manapool *active-player* (+ 1 (get-player-manapool *active-player*))))

(defun pay-mana (cost)
        (set-player-manapool *active-player* (- (get-player-manapool *active-player*) cost)))

(defun play-card (inname)
        (let* ((handcards (get-player-hand *active-player*))
               (c (find-if (lambda (x) (equalp inname (get-card-name x))) handcards)))
                (if c
		    (if (land? c)
			(progn (format t "playing ~a~%" (get-card-name c))
			       (setf *battlefield* (cons c *battlefield*))
			       (set-player-hand *active-player* (remove c handcards :count 1)))
		        (format t "not a land, use cast for spells~%"))
                    (format t "not a card in your hand~%"))))

(defun cast-card (inname)
        (let* ((handcards (get-player-hand *active-player*))
               (c (find-if (lambda (x) (equalp inname (get-card-name x))) handcards)))
                (if c
		    (if (land? c)
			(format t "can't cast land, use play instead~%")
			(if (>= (get-player-manapool *active-player*) (get-card-cmc c)) 
			    (progn (format t "casting ~a~%" (get-card-name c))
				   (pay-mana (get-card-cmc c))
				   (setf *battlefield* (cons c *battlefield*))
				   (set-player-hand *active-player* (remove c handcards :count 1)))
			    (format t "insufficient mana~%")))
                    (format t "not a card in your card~%"))))

(defun describe-card (inname)
        (let1 c (find-if (lambda (x) (equalp inname (get-card-name x))) *all-cards*)
                (if c
                    (print-card c)
                    (format t "not a valid card name~%"))))

(defun tap-card (nstr)
        (handler-case 
	    (let1 c (nth (parse-integer nstr) *battlefield*)
	          (if (tapped? c)
		      (format t "~a already tapped~%" (get-card-name c))
   		      (progn (tap! c)
			     (free-mana)
			     (format t "tapped ~a~%" (get-card-name c)))))
	    (condition () (format t "enter an integer between 0 and battlefieldsize-1~%"))))
	  
(defun untap-card (nstr)
        (handler-case 
	    (let1 c (nth (parse-integer nstr) *battlefield*)
	          (if (tapped? c)
   		      (progn (untap! c)
			     (format t "untapped ~a~%" (get-card-name c)))
		      (format t "~a already untapped~%" (get-card-name c))))
	    (condition () (format t "enter an integer between 0 and battlefieldsize-1~%"))))

(defun get-priority ()
	(loop   (with-color 'red (format t "~a-> " (get-player-name *active-player*)))
                (finish-output nil)
                (let1 a (read-line)
                        (cond ((equalp a "concede")          (progn (format t "conceding~%") (concede *player1*) (return)))
                              ((equalp a "p")                                                                    (return))
                              ((string-begins-with a "cast")  (cast-card     (string-trim-first-n a 5)))
                              ((string-begins-with a "play")  (play-card     (string-trim-first-n a 5)))
                              ((string-begins-with a "desc")  (describe-card (string-trim-first-n a 5)))
                              ((string-begins-with a "tap")   (tap-card      (string-trim-first-n a 4)))
                              ((string-begins-with a "untap") (untap-card    (string-trim-first-n a 6)))
                              ((equalp a "activate")          (format t "activate~%"))
                              ((equalp a "faceup")            (format t "faceup"))
                              ((equalp a "mp")                (list-manapool))
                              ((equalp a "fm")                (free-mana))
                              ((equalp a "h")                 (list-hand))
                              ((equalp a "b")                 (list-battlefield))
                              ((equalp a "g")                 (list-graveyard))
                              ((equalp a "e")                 (list-exile))
                              (t                              (list-commands))))))

(defun untap-step () 
        (with-color 'yellow (format t "Untap Step~%"))
        ;(phasing)
        ;(untap-all))
        nil)

(defun upkeep-step () 
        (with-color 'yellow (format t "Upkeep Step~%"))
        ;(triggers)
        (get-priority)
        nil)

(defun draw-step ()
        (with-color 'yellow (format t "Draw Step~%"))
        (draw *player1*)
        ;(draw active-player 1)
        ;(triggers)
        (get-priority)
        nil)

(defun beginning-phase ()
        (with-color 'green (format t "--- Beginning Phase ---~%"))
	(untap-step)
	(upkeep-step)
	(draw-step))

(defun main-phase (which)
        (with-color 'green (format t "--- Main Phase ~a ---~%" which))
	(get-priority)
        ;(play-land))
        nil)

(defun beginning-of-combat-step ()
      (with-color 'yellow (format t "Beginning of Combat Step~%"))
      ;507.1. First, if the game being played is a multiplayer game in which the active player’s opponents don’t all automatically become defending players,
      ;       the active player chooses one of his or her opponents. That player becomes the defending player. This turn-based action doesn’t use the stack. (See rule 506.2.)
      ;507.2. Second, any abilities that trigger at the beginning of combat go on the stack. (See rule 603, “Handling Triggered Abilities.”)
      (get-priority)) ;507.3

(defun declare-attackers-step () 
      (with-color 'yellow (format t "Declare Attackers Step~%"))
      (get-priority))

(defun declare-blockers-step ()
      (with-color 'yellow (format t "Declare Blockers Step~%"))
      (get-priority))

(defun combat-damage-step () 
      (with-color 'yellow (format t "Combat Damage Step~%"))
      (get-priority))

(defun end-of-combat-step ()
      (with-color 'yellow (format t "End of Combat Step~%"))
      ; 511.1 First, all “at end of combat” abilities trigger and go on the stack. (See rule 603, “Handling Triggered Abilities.”) 
      (get-priority)) ;511.2
      ; 511.3 As soon as the end of combat step ends, all creatures and planeswalkers are removed from combat.
      ;       After the end of combat step ends, the combat phase is over and the postcombat main phase begins (see rule 505).

(defun combat-phase ()
        (with-color 'green (format t "--- Combat Phase ---~%"))
        (beginning-of-combat-step)
        (declare-attackers-step)
        (declare-blockers-step)
        (combat-damage-step)
        (end-of-combat-step))

(defun end-step ()
        (with-color 'yellow (format t "End Step~%"))
	(get-priority))

(defun cleanup-step ()
        (with-color 'yellow (format t "Cleanup Step~%")))

(defun ending-phase ()
        (with-color 'green (format t "--- Ending Phase ---~%"))
	(end-step)
	(cleanup-step))

(defun turn (player)
        (setf *active-player* player) 
        (with-color 'cyan (format t "========= ~a's Turn =========~%" (get-player-name player)))
	(beginning-phase)
	(main-phase 1)
	(combat-phase)
	(main-phase 2)
	(ending-phase))
