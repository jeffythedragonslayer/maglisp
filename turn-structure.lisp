(defparameter *active-player*    nil)
(defparameter *nonactive-player* nil)

(defun list-hand        () (mapcar (lambda (x) (format t "~a~%" (get-card-name x))) (get-player-hand *active-player*)))
(defun list-graveyard   () (mapcar (lambda (x) (format t "~a~%" (get-card-name x))) *graveyard*))
(defun list-exile       () (mapcar (lambda (x) (format t "~a~%" (get-card-name x))) *exile*))

(defun list-battlefield ()
        (mapcar (lambda (x) (print-card x)) *battlefield*))

(defun list-manapool ()
        (format t "~a~%" (get-player-manapool *active-player*)))

(defun list-life ()
        (format t "blah"))

(defun list-commands ()
        (format t "commands available:~%")
        (format t "p                    - pass priority~%")
        (format t "h                    - list cards in hand~%")
        (format t "b                    - list cards on battlefield~%")
        (format t "g                    - list cards in graveyard~%")
        (format t "e                    - list cards in exile zone~%")
        (format t "fm                   - free mana~%")
        (format t "mp                   - see mana pool~%")
        (format t "desc [card]          - describe text on card~%")
        (format t "cast [card]          - cast a card~%")
        (format t "play [land]          - play a land~%")
        (format t "tap [bnum]           - tap a land for mana")
        (format t "untap [bnum]         - untap a land for mana")
        (format t "attack [bnum]        - attack opponent with a creature")
        (format t "activate [ability]   - activate an ability~%")
        (format t "faceup [permanent]   - turn a permanent faceup~%")
        (format t "concede              - concede the game~%"))

(defun free-mana ()
        (set-player-manapool *active-player* (+ 1 (get-player-manapool *active-player*))))

(defun pay-mana (cost)
        (set-player-manapool *active-player* (- (get-player-manapool *active-player*) cost)))

(defun play-card (inname)
        (let* ((handcards (get-player-hand *active-player*))
               (c (find-if (lambda (x) (equalp inname (get-card-name x))) handcards)))
                (if c
		    (if (land? c)
			(if (get-player-playedland *active-player*)
			    (format t "already played a land this turn~%")
			    (progn (format t "playing ~a~%" (get-card-name c))
				   (setf *battlefield* (cons c *battlefield*))
				   (set-player-playedland *active-player* t)
				   (set-player-hand *active-player* (remove c handcards :count 1))))
		        (format t "not a land, use cast for spells~%"))
                    (format t "not a card in your hand~%"))))

(defun cast-card (inname)
        (let* ((handcards (get-player-hand *active-player*))
               (c (find-if (lambda (x) (equalp inname (get-card-name x))) handcards)))
                (if c
		    (if (land? c)
			(format t "can't cast land, use play instead~%")
			(if (>= (get-player-manapool *active-player*) (get-card-cmc c)) 
			    (progn (format t "casting ~a~%" (get-card-name c))
				   (pay-mana (get-card-cmc c))
				   (sick! c)
				   (setf *battlefield* (cons c *battlefield*))
				   (set-player-hand *active-player* (remove c handcards :count 1)))
			    (format t "insufficient mana, ~a costs ~a~%" (get-card-name c) (get-card-cmc c))))
                    (format t "not a card in your hand~%"))))

(defun describe-card (inname)
        (let1 c (find-if (lambda (x) (equalp inname (get-card-name x))) *all-cards*)
                (if c
                    (print-card c)
                    (format t "not a valid card name~%"))))

(defun tap-card (nstr)
        (handler-case 
	    (let1 c (nth (parse-integer nstr) *battlefield*)
	          (if (tapped? c)
		      (format t "~a already tapped~%" (get-card-name c))
   		      (progn (tap! c)
			     (free-mana)
			     (format t "tapped ~a~%" (get-card-name c)))))
	    (condition () (format t "enter an integer between 0 and battlefieldsize-1~%"))))
	  
(defun untap-card (nstr)
        (handler-case 
	    (let1 c (nth (parse-integer nstr) *battlefield*)
	          (if (tapped? c)
   		      (progn (untap! c)
			     (format t "untapped ~a~%" (get-card-name c)))
		      (format t "~a already untapped~%" (get-card-name c))))
	    (condition () (format t "enter an integer between 0 and battlefieldsize-1~%"))))

(defun attack-withcard (nstr)
        (handler-case
	        (let1 c (nth (parse-integer nstr) *battlefield*)
		      (if (creature? c)
			  (if (sick? c)
			      (format t "~a has summoning sickness, can't attack this turn~%" (get-card-name c))
 			      (if (tapped? c)
 			 	  (format t "~a tapped, can't attack~%" (get-card-name c))
 			 	  (let1 num (get-card-power c)
 				        (lose-life *nonactive-player* num)
				        (format t "~a dealt ~a damage to ~a~%" (get-card-name c) num (get-player-name *nonactive-player*)))))
			  (format t "~a not a creature, can't attack~%" (get-card-name c))))
                (condition () (format t "enter an integer between 0 and battlefieldsize-1~%"))))

(defun get-priority ()
	(loop   (with-color 'red (format t "~a-> " (get-player-name *active-player*)))
                (finish-output nil)
                (let1 a (read-line)
                        (cond ((equalp a "concede")          (progn (format t "conceding~%") (concede *active-player*) (return)))
                              ((equalp a "p")                                                                          (return))
                              ((string-begins-with a "cast")   (cast-card       (string-trim-first-n a 5)))
                              ((string-begins-with a "play")   (play-card       (string-trim-first-n a 5)))
                              ((string-begins-with a "desc")   (describe-card   (string-trim-first-n a 5)))
                              ((string-begins-with a "tap")    (tap-card        (string-trim-first-n a 4)))
                              ((string-begins-with a "untap")  (untap-card      (string-trim-first-n a 6)))
			      ((string-begins-with a "attack") (attack-withcard (string-trim-first-n a 7)))
                              ((equalp a "activate")           (format t "activate~%"))
                              ((equalp a "faceup")             (format t "faceup"))
                              ((equalp a "mp")                 (list-manapool))
                              ((equalp a "fm")                 (free-mana))
                              ((equalp a "h")                  (list-hand))
                              ((equalp a "b")                  (list-battlefield))
                              ((equalp a "g")                  (list-graveyard))
                              ((equalp a "e")                  (list-exile))
			      ((equalp a "life")               (list-life))
                              (t                               (list-commands))))))

(defun untap-all       () (mapcar #'untap! *battlefield*)) 
(defun empty-manapools () (mapcar #'empty-manapool *all-players*))

(defun untap-step () 
        (with-color 'yellow (format t "Untap Step~%"))
        ;(phasing)
        (untap-all)
        (empty-manapools))

(defun upkeep-step () 
        (with-color 'yellow (format t "Upkeep Step~%"))
        ;(triggers)
        (get-priority)
        (empty-manapools))

(defun draw-step ()
        (with-color 'yellow (format t "Draw Step~%"))
        (draw *active-player*) 
        ;(draw active-player 1)
        ;(triggers)
        (get-priority)
        (empty-manapools))

(defun beginning-phase ()
        (with-color 'green (format t "--- Beginning Phase ---~%"))
	(untap-step)
	(upkeep-step)
	(draw-step)
        (empty-manapools))

(defun main-phase (which)
        (with-color 'green (format t "--- Main Phase ~a ---~%" which))
	(get-priority)
        (empty-manapools))

(defun beginning-of-combat-step ()
      (with-color 'yellow (format t "Beginning of Combat Step~%"))
      ;507.1. First, if the game being played is a multiplayer game in which the active player’s opponents don’t all automatically become defending players,
      ;       the active player chooses one of his or her opponents. That player becomes the defending player. This turn-based action doesn’t use the stack. (See rule 506.2.)
      ;507.2. Second, any abilities that trigger at the beginning of combat go on the stack. (See rule 603, “Handling Triggered Abilities.”)
      (get-priority) ;507.3
      (empty-manapools))


(defun declare-attackers-step () 
      (with-color 'yellow (format t "Declare Attackers Step~%"))
      (get-priority)
      (empty-manapools))

(defun declare-blockers-step ()
      (with-color 'yellow (format t "Declare Blockers Step~%"))
      (get-priority)
      (empty-manapools))

(defun combat-damage-step () 
      (with-color 'yellow (format t "Combat Damage Step~%"))
      (get-priority)
      (empty-manapools))

(defun end-of-combat-step ()
      (with-color 'yellow (format t "End of Combat Step~%"))
      ; 511.1 First, all “at end of combat” abilities trigger and go on the stack. (See rule 603, “Handling Triggered Abilities.”) 
      (get-priority) ;511.2
      ; 511.3 As soon as the end of combat step ends, all creatures and planeswalkers are removed from combat.
      ;       After the end of combat step ends, the combat phase is over and the postcombat main phase begins (see rule 505).
      (empty-manapools))

(defun combat-phase ()
        (with-color 'green (format t "--- Combat Phase ---~%"))
        (beginning-of-combat-step)
        (declare-attackers-step)
        (declare-blockers-step)
        (combat-damage-step)
        (end-of-combat-step)
        (empty-manapools))

(defun end-step ()
        (with-color 'yellow (format t "End Step~%"))
	(get-priority)
        (empty-manapools))

(defun cleanup-step ()
        (with-color 'yellow (format t "Cleanup Step~%"))
        (empty-manapools))


(defun ending-phase ()
        (with-color 'green (format t "--- Ending Phase ---~%"))
	(end-step)
	(cleanup-step)
        (empty-manapools))

(defun reset-summoning-sickness ()
        (mapcar #'notsick! *battlefield*))

(defun turn (player)
        (setf *active-player* player) 
	(if (equal *active-player* *bob*)
	    (setf *nonactive-player* *alice*)
	    (setf *nonactive-player* *alice*))
	  
	(set-player-playedland *active-player* nil)
	(reset-summoning-sickness)
        (with-color 'cyan (format t "========= ~a's Turn =========~%" (get-player-name player)))
	(beginning-phase)
	(main-phase 1)
	(combat-phase)
	(main-phase 2)
	(ending-phase))
